# PPT内容排版优化功能 - 实现细节

> **补充文档**: 详细代码实现和最佳实践  
> **创建日期**: 2025-10-28  
> **版本**: v1.0

## 目录
1. [前端详细实现](#1-前端详细实现)
2. [后端详细实现](#2-后端详细实现)
3. [LLM提示词工程](#3-llm提示词工程)
4. [最佳实践和注意事项](#4-最佳实践和注意事项)

---

## 1. 前端详细实现

### 1.1 魔术按钮组件

```vue
<!-- frontend/src/views/Editor/Toolbar/MagicButton.vue -->
<template>
  <div class="magic-button-wrapper">
    <el-tooltip
      content="智能优化当前幻灯片排版"
      placement="bottom"
      :disabled="loading"
    >
      <el-button
        class="magic-button"
        :class="{ 'is-loading': loading }"
        :disabled="loading || disabled"
        @click="handleOptimize"
      >
        <svg-icon
          name="magic-wand"
          class="magic-icon"
          :class="{ 'rotating': loading }"
        />
        <span v-if="!loading">优化排版</span>
        <span v-else>优化中...</span>
      </el-button>
    </el-tooltip>
  </div>
</template>

<script lang="ts" setup>
import { ref, computed } from 'vue';
import { storeToRefs } from 'pinia';
import { useSlidesStore } from '@/store';
import { message } from '@/utils/message';
import { optimizeSlideLayout } from '@/services/optimization';
import { useHistorySnapshot } from '@/hooks/useHistorySnapshot';

const slidesStore = useSlidesStore();
const { currentSlide, viewportSize, viewportRatio } = storeToRefs(slidesStore);
const { addHistorySnapshot } = useHistorySnapshot();

const loading = ref(false);

// 禁用条件：没有元素或正在加载
const disabled = computed(() => {
  return !currentSlide.value || 
         currentSlide.value.elements.length === 0;
});

// 处理优化请求
const handleOptimize = async () => {
  if (!currentSlide.value) {
    message.error('请先选择一个幻灯片');
    return;
  }

  if (currentSlide.value.elements.length === 0) {
    message.error('当前幻灯片没有可优化的元素');
    return;
  }

  loading.value = true;

  try {
    // 收集幻灯片数据
    const slideData = {
      slideId: currentSlide.value.id,
      elements: currentSlide.value.elements,
      canvasSize: {
        width: viewportSize.value,
        height: viewportSize.value * viewportRatio.value
      }
    };

    // 调用优化服务
    const response = await optimizeSlideLayout(slideData);

    if (response.success && response.elements) {
      // 添加历史快照（支持撤销）
      addHistorySnapshot();

      // 更新幻灯片元素
      slidesStore.updateSlide({
        elements: response.elements
      });

      message.success('排版优化完成！');
    } else {
      throw new Error(response.error || '优化失败');
    }
  } catch (error: any) {
    console.error('优化失败:', error);
    message.error(`排版优化失败：${error.message}`);
  } finally {
    loading.value = false;
  }
};
</script>

<style lang="scss" scoped>
.magic-button-wrapper {
  display: inline-block;
}

.magic-button {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 16px;
  font-size: 14px;
  border-radius: 4px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  border: none;
  cursor: pointer;
  transition: all 0.3s ease;

  &:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
  }

  &:active:not(:disabled) {
    transform: translateY(0);
  }

  &:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }

  &.is-loading {
    cursor: wait;
  }
}

.magic-icon {
  width: 16px;
  height: 16px;

  &.rotating {
    animation: rotate 2s linear infinite;
  }
}

@keyframes rotate {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}
</style>
```

### 1.2 优化服务模块

```typescript
// frontend/src/services/optimization.ts

import { api } from './api';
import type { PPTElement } from '@/types/slides';

/**
 * 优化请求数据
 */
export interface OptimizationRequest {
  slideId: string;
  elements: PPTElement[];
  canvasSize: {
    width: number;
    height: number;
  };
  options?: {
    keepColors?: boolean;
    keepFonts?: boolean;
    style?: 'professional' | 'creative' | 'minimal';
  };
}

/**
 * 优化响应数据
 */
export interface OptimizationResponse {
  success: boolean;
  elements?: PPTElement[];
  description?: string;
  duration?: number;
  error?: string;
}

/**
 * 精简元素数据，减少传输量
 */
function simplifyElement(element: PPTElement): any {
  const base = {
    id: element.id,
    type: element.type,
    left: element.left,
    top: element.top,
    width: element.width,
    height: element.height,
    rotate: element.rotate,
  };

  // 根据元素类型添加特定字段
  switch (element.type) {
    case 'text':
      return {
        ...base,
        content: element.content,
        defaultFontName: element.defaultFontName,
        defaultColor: element.defaultColor,
        lineHeight: element.lineHeight,
      };

    case 'shape':
      return {
        ...base,
        fill: element.fill,
        outline: element.outline,
        text: element.text,
      };

    case 'image':
      return {
        ...base,
        src: element.src,
        fixedRatio: element.fixedRatio,
      };

    default:
      return base;
  }
}

/**
 * 优化幻灯片布局
 */
export async function optimizeSlideLayout(
  request: OptimizationRequest
): Promise<OptimizationResponse> {
  try {
    // 精简元素数据
    const simplifiedElements = request.elements.map(simplifyElement);

    // 发送请求
    const response = await api.post<{
      success: boolean;
      data?: {
        slide_id: string;
        elements: any[];
        description?: string;
        duration?: number;
      };
      error?: {
        code: string;
        message: string;
      };
    }>('/layout/optimize', {
      slide_id: request.slideId,
      elements: simplifiedElements,
      canvas_size: request.canvasSize,
      options: request.options,
    });

    if (response.data.success && response.data.data) {
      return {
        success: true,
        elements: response.data.data.elements,
        description: response.data.data.description,
        duration: response.data.data.duration,
      };
    } else {
      return {
        success: false,
        error: response.data.error?.message || '优化失败',
      };
    }
  } catch (error: any) {
    console.error('优化请求失败:', error);
    return {
      success: false,
      error: error.message || '网络请求失败',
    };
  }
}

/**
 * 批量优化多个幻灯片
 */
export async function optimizeMultipleSlides(
  slides: Array<{
    slideId: string;
    elements: PPTElement[];
  }>,
  canvasSize: { width: number; height: number }
): Promise<Map<string, OptimizationResponse>> {
  const results = new Map<string, OptimizationResponse>();

  // 串行处理，避免过载
  for (const slide of slides) {
    const response = await optimizeSlideLayout({
      slideId: slide.slideId,
      elements: slide.elements,
      canvasSize,
    });

    results.set(slide.slideId, response);

    // 如果失败，停止后续优化
    if (!response.success) {
      break;
    }

    // 避免请求过快
    await new Promise(resolve => setTimeout(resolve, 500));
  }

  return results;
}
```

### 1.3 API配置

```typescript
// frontend/src/services/api.ts

import axios, { type AxiosInstance } from 'axios';
import { message } from '@/utils/message';

const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || '/api/v1';
const API_TIMEOUT = 30000; // 30秒超时

class APIClient {
  private instance: AxiosInstance;

  constructor() {
    this.instance = axios.create({
      baseURL: API_BASE_URL,
      timeout: API_TIMEOUT,
      headers: {
        'Content-Type': 'application/json',
      },
    });

    this.setupInterceptors();
  }

  private setupInterceptors() {
    // 请求拦截器
    this.instance.interceptors.request.use(
      (config) => {
        // 添加认证token（如果需要）
        const token = localStorage.getItem('access_token');
        if (token) {
          config.headers.Authorization = `Bearer ${token}`;
        }
        return config;
      },
      (error) => {
        return Promise.reject(error);
      }
    );

    // 响应拦截器
    this.instance.interceptors.response.use(
      (response) => response,
      (error) => {
        // 处理网络错误
        if (error.code === 'ECONNABORTED') {
          message.error('请求超时，请稍后重试');
        } else if (!error.response) {
          message.error('网络连接失败，请检查网络设置');
        } else if (error.response.status === 401) {
          message.error('未授权，请重新登录');
          // 跳转到登录页
          window.location.href = '/login';
        } else if (error.response.status >= 500) {
          message.error('服务器错误，请稍后重试');
        }

        return Promise.reject(error);
      }
    );
  }

  // GET请求
  async get<T = any>(url: string, config?: any): Promise<T> {
    const response = await this.instance.get<T>(url, config);
    return response.data;
  }

  // POST请求
  async post<T = any>(url: string, data?: any, config?: any): Promise<T> {
    const response = await this.instance.post<T>(url, data, config);
    return response.data;
  }

  // PUT请求
  async put<T = any>(url: string, data?: any, config?: any): Promise<T> {
    const response = await this.instance.put<T>(url, data, config);
    return response.data;
  }

  // DELETE请求
  async delete<T = any>(url: string, config?: any): Promise<T> {
    const response = await this.instance.delete<T>(url, config);
    return response.data;
  }
}

export const api = new APIClient();
```

---

## 2. 后端详细实现

### 2.1 API端点

```python
# backend/app/api/v1/endpoints/layout_optimization.py

"""
布局优化API端点
提供幻灯片排版优化功能
"""

from typing import Optional
import time
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession

from app.db.database import get_db
from app.schemas.layout_optimization import (
    LayoutOptimizationRequest,
    LayoutOptimizationStandardResponse,
    LayoutOptimizationResponse
)
from app.schemas.common import StandardResponse
from app.services.layout.layout_optimization_service import LayoutOptimizationService
from app.core.log_utils import get_logger
from app.utils.cache import get_redis_client
import hashlib
import json

logger = get_logger(__name__)
router = APIRouter(tags=["Layout Optimization"])


def generate_cache_key(request: LayoutOptimizationRequest) -> str:
    """
    生成缓存键
    基于请求内容的哈希值，相同输入返回相同缓存
    """
    # 序列化请求数据
    data = {
        "elements": [el.model_dump() for el in request.elements],
        "canvas_size": request.canvas_size.model_dump(),
        "options": request.options.model_dump() if request.options else {}
    }

    # 生成哈希
    content_hash = hashlib.sha256(
        json.dumps(data, sort_keys=True).encode()
    ).hexdigest()

    return f"layout_opt:{content_hash[:16]}"


@router.post(
    "/optimize",
    response_model=LayoutOptimizationStandardResponse,
    summary="优化幻灯片布局",
    description="使用LLM智能优化幻灯片的排版布局"
)
async def optimize_slide_layout(
    request: LayoutOptimizationRequest,
    db: AsyncSession = Depends(get_db)
) -> LayoutOptimizationStandardResponse:
    """
    优化幻灯片布局

    Args:
        request: 布局优化请求
        db: 数据库会话

    Returns:
        LayoutOptimizationStandardResponse: 优化结果
    """
    start_time = time.time()

    try:
        logger.info(
            "接收到布局优化请求",
            operation="layout_optimization_request",
            slide_id=request.slide_id,
            elements_count=len(request.elements)
        )

        # 验证元素数量
        if len(request.elements) == 0:
            return LayoutOptimizationStandardResponse(
                success=False,
                error={
                    "code": "INVALID_REQUEST",
                    "message": "元素列表不能为空"
                }
            )

        if len(request.elements) > 50:
            return LayoutOptimizationStandardResponse(
                success=False,
                error={
                    "code": "TOO_MANY_ELEMENTS",
                    "message": "元素数量超过限制（最多50个）"
                }
            )

        # 生成缓存键
        cache_key = generate_cache_key(request)
        redis_client = await get_redis_client()

        # 检查缓存
        if redis_client:
            cached_result = await redis_client.get(cache_key)
            if cached_result:
                logger.info(
                    "命中缓存",
                    operation="layout_optimization_cache_hit",
                    cache_key=cache_key
                )
                # 解析缓存数据
                cached_data = json.loads(cached_result)
                return LayoutOptimizationStandardResponse(
                    success=True,
                    data=LayoutOptimizationResponse(**cached_data),
                    message="布局优化完成（来自缓存）"
                )

        # 调用优化服务
        service = LayoutOptimizationService(db)
        optimized_elements = await service.optimize_layout(
            slide_id=request.slide_id,
            elements=request.elements,
            canvas_size=request.canvas_size,
            options=request.options
        )

        # 构建响应
        duration = time.time() - start_time
        response = LayoutOptimizationResponse(
            slide_id=request.slide_id,
            elements=optimized_elements,
            duration=duration
        )

        # 缓存结果
        if redis_client:
            try:
                await redis_client.setex(
                    cache_key,
                    3600,  # 1小时过期
                    response.model_dump_json()
                )
                logger.info(
                    "结果已缓存",
                    operation="layout_optimization_cached",
                    cache_key=cache_key
                )
            except Exception as e:
                logger.warning(
                    "缓存结果失败",
                    operation="layout_optimization_cache_failed",
                    exception=str(e)
                )

        logger.info(
            "布局优化完成",
            operation="layout_optimization_success",
            slide_id=request.slide_id,
            duration=duration
        )

        return LayoutOptimizationStandardResponse(
            success=True,
            data=response,
            message="布局优化完成"
        )

    except Exception as e:
        logger.error(
            "布局优化失败",
            operation="layout_optimization_failed",
            slide_id=request.slide_id if request else None,
            exception=str(e)
        )

        return LayoutOptimizationStandardResponse(
            success=False,
            error={
                "code": "OPTIMIZATION_FAILED",
                "message": f"优化失败：{str(e)}"
            }
        )
```

### 2.2 优化服务

```python
# backend/app/services/layout/layout_optimization_service.py

"""
布局优化服务
负责调用LLM进行幻灯片布局优化
"""

from typing import List, Optional, Dict, Any
import json
import re
from sqlalchemy.ext.asyncio import AsyncSession

from app.schemas.layout_optimization import (
    ElementData,
    CanvasSize,
    OptimizationOptions
)
from app.core.llm.client import AIClient
from app.core.log_utils import get_logger
from app.prompts.utils import load_prompt_template

logger = get_logger(__name__)


class LayoutOptimizationService:
    """布局优化服务"""

    def __init__(self, db: AsyncSession):
        self.db = db
        self.ai_client = AIClient()

    async def optimize_layout(
        self,
        slide_id: str,
        elements: List[ElementData],
        canvas_size: CanvasSize,
        options: Optional[OptimizationOptions] = None
    ) -> List[ElementData]:
        """
        优化幻灯片布局

        Args:
            slide_id: 幻灯片ID
            elements: 元素列表
            canvas_size: 画布尺寸
            options: 优化选项

        Returns:
            List[ElementData]: 优化后的元素列表
        """
        logger.info(
            "开始布局优化",
            operation="optimize_layout_start",
            slide_id=slide_id,
            elements_count=len(elements)
        )

        try:
            # 1. 转换为LLM格式
            llm_input = self._convert_to_llm_format(
                elements, canvas_size, options
            )

            # 2. 构建提示词
            system_prompt = self._build_system_prompt()
            user_prompt = self._build_user_prompt(llm_input, options)

            logger.info(
                "调用LLM进行优化",
                operation="optimize_layout_llm_call",
                slide_id=slide_id
            )

            # 3. 调用LLM
            llm_response = await self.ai_client.ai_call(
                system_prompt=system_prompt,
                user_prompt=user_prompt,
                temperature=0.7,
                max_tokens=2000
            )

            logger.info(
                "LLM响应接收完成",
                operation="optimize_layout_llm_response",
                response_length=len(llm_response)
            )

            # 4. 解析LLM响应
            optimized_data = self._parse_llm_response(llm_response)

            # 5. 转换回前端格式
            optimized_elements = self._convert_to_frontend_format(
                optimized_data, elements
            )

            # 6. 验证结果
            self._validate_optimized_elements(optimized_elements, elements)

            logger.info(
                "布局优化成功",
                operation="optimize_layout_success",
                slide_id=slide_id,
                optimized_count=len(optimized_elements)
            )

            return optimized_elements

        except Exception as e:
            logger.error(
                "布局优化失败",
                operation="optimize_layout_failed",
                slide_id=slide_id,
                exception=str(e)
            )
            raise

    def _convert_to_llm_format(
        self,
        elements: List[ElementData],
        canvas_size: CanvasSize,
        options: Optional[OptimizationOptions]
    ) -> Dict[str, Any]:
        """转换为LLM可理解的格式"""
        return {
            "canvas": {
                "width": canvas_size.width,
                "height": canvas_size.height
            },
            "elements": [
                {
                    "id": el.id,
                    "type": el.type,
                    "position": {"x": el.left, "y": el.top},
                    "size": {"width": el.width, "height": el.height},
                    "rotate": el.rotate,
                    **({"content": el.content} if el.content else {}),
                    **({"style": {
                        "font": el.defaultFontName,
                        "color": el.defaultColor,
                        "lineHeight": el.lineHeight
                    }} if el.defaultFontName else {}),
                    **({"fill": el.fill} if el.fill else {}),
                    **({"text": el.text} if el.text else {})
                }
                for el in elements
            ],
            "options": options.model_dump() if options else {}
        }

    def _build_system_prompt(self) -> str:
        """构建系统提示词"""
        return load_prompt_template(
            "layout_optimization/system_prompt.txt"
        )

    def _build_user_prompt(
        self,
        llm_input: Dict[str, Any],
        options: Optional[OptimizationOptions]
    ) -> str:
        """构建用户提示词"""
        template = load_prompt_template(
            "layout_optimization/user_prompt.txt"
        )

        # 生成优化要求
        requirements = []
        if options:
            if options.keep_colors:
                requirements.append("- 保持原有颜色方案")
            if options.keep_fonts:
                requirements.append("- 保持原有字体")
            requirements.append(f"- 优化风格：{options.style}")

        requirements_text = "\n".join(requirements) if requirements else "- 遵循专业设计原则"

        # 填充模板
        return template.format(
            canvas_width=llm_input["canvas"]["width"],
            canvas_height=llm_input["canvas"]["height"],
            elements_json=json.dumps(llm_input["elements"], indent=2, ensure_ascii=False),
            optimization_requirements=requirements_text
        )

    def _parse_llm_response(self, response: str) -> Dict[str, Any]:
        """解析LLM响应"""
        try:
            # 1. 尝试提取JSON代码块
            json_match = re.search(
                r'```json\s*(.*?)\s*```',
                response,
                re.DOTALL
            )

            if json_match:
                json_str = json_match.group(1)
            else:
                # 2. 尝试直接解析整个响应
                json_str = response

            # 3. 解析JSON
            parsed = json.loads(json_str)

            # 4. 验证必要字段
            if "optimized_elements" not in parsed:
                raise ValueError("响应中缺少optimized_elements字段")

            return parsed

        except json.JSONDecodeError as e:
            logger.error(
                "解析LLM响应失败",
                operation="parse_llm_response_failed",
                exception=str(e),
                response_preview=response[:200]
            )
            raise ValueError(f"无法解析LLM响应：{str(e)}")

    def _convert_to_frontend_format(
        self,
        optimized_data: Dict[str, Any],
        original_elements: List[ElementData]
    ) -> List[ElementData]:
        """转换回前端格式"""
        # 创建原始元素的映射
        element_map = {el.id: el for el in original_elements}

        optimized_elements = []

        for opt_el in optimized_data["optimized_elements"]:
            el_id = opt_el["id"]
            if el_id not in element_map:
                logger.warning(
                    "优化结果中包含未知元素ID",
                    element_id=el_id
                )
                continue

            # 获取原始元素
            original_el = element_map[el_id]

            # 更新位置和尺寸
            updated_el = original_el.model_copy(update={
                "left": opt_el["position"]["x"],
                "top": opt_el["position"]["y"],
                "width": opt_el["size"]["width"],
                "height": opt_el["size"]["height"],
            })

            # 更新样式（如果有）
            if "style" in opt_el and original_el.type == "text":
                if "font" in opt_el["style"]:
                    updated_el.defaultFontName = opt_el["style"]["font"]
                if "color" in opt_el["style"]:
                    updated_el.defaultColor = opt_el["style"]["color"]
                if "lineHeight" in opt_el["style"]:
                    updated_el.lineHeight = opt_el["style"]["lineHeight"]

            # 更新填充色（如果有）
            if "fill" in opt_el and original_el.type == "shape":
                updated_el.fill = opt_el["fill"]

            optimized_elements.append(updated_el)

        return optimized_elements

    def _validate_optimized_elements(
        self,
        optimized: List[ElementData],
        original: List[ElementData]
    ):
        """验证优化结果"""
        # 1. 元素数量应该一致
        if len(optimized) != len(original):
            raise ValueError(
                f"优化后元素数量({len(optimized)})与原始数量({len(original)})不匹配"
            )

        # 2. 所有元素ID应该保持一致
        original_ids = {el.id for el in original}
        optimized_ids = {el.id for el in optimized}

        if original_ids != optimized_ids:
            missing = original_ids - optimized_ids
            extra = optimized_ids - original_ids
            raise ValueError(
                f"元素ID不匹配：缺失{missing}，多余{extra}"
            )

        # 3. 验证文本内容未被修改（如果是文本元素）
        for orig_el, opt_el in zip(original, optimized):
            if orig_el.type == "text" and orig_el.content:
                if opt_el.content != orig_el.content:
                    logger.warning(
                        "文本内容被修改",
                        element_id=orig_el.id,
                        original_content=orig_el.content[:50],
                        optimized_content=opt_el.content[:50]
                    )
                    # 恢复原始内容
                    opt_el.content = orig_el.content
```

### 2.3 提示词模板

```
# backend/app/prompts/layout_optimization/system_prompt.txt

你是一位专业的演示文稿设计专家，精通排版设计原则和视觉传达理论。你的任务是优化PowerPoint幻灯片的布局，使其更加美观、专业和易读。

核心原则：
1. **内容不变**：严格保持所有文字内容不变，不得修改、删除或添加任何文字
2. **视觉层次**：通过字体大小、位置、颜色建立清晰的视觉层次
3. **对齐原则**：确保元素之间的对齐关系，使用网格系统
4. **留白空间**：合理利用留白，避免过度拥挤
5. **色彩协调**：优化配色方案，提升视觉吸引力
6. **比例平衡**：保持元素之间的比例协调

设计规范：
- 标题字体：36-48px，加粗，视觉焦点
- 正文字体：18-24px，易读
- 元素间距：至少20px
- 边距：距离画布边缘至少50px
- 对齐方式：优先使用居中或左对齐

输出要求：
以JSON格式返回优化后的元素布局数据，包含每个元素的位置、大小和样式属性。
确保JSON格式正确，可以被解析。
```

```
# backend/app/prompts/layout_optimization/user_prompt.txt

请优化以下幻灯片的布局设计：

## 画布信息
- 宽度：{canvas_width}px
- 高度：{canvas_height}px

## 当前元素布局
```json
{elements_json}
```

## 优化要求
{optimization_requirements}

请返回优化后的布局数据，格式如下：
```json
{{
  "optimized_elements": [
    {{
      "id": "元素ID（必须与原始ID一致）",
      "position": {{ "x": 数值, "y": 数值 }},
      "size": {{ "width": 数值, "height": 数值 }},
      "style": {{
        "font": "字体名称",
        "fontSize": 数值,
        "color": "#颜色值"
      }}
    }}
  ],
  "optimization_notes": "优化说明"
}}
```

注意事项：
1. 保持所有元素的ID不变
2. 确保元素不超出画布范围
3. 元素之间不要重叠（除非原本就重叠）
4. 文字内容绝对不能修改
5. 返回的JSON必须是有效格式
```

---

## 3. LLM提示词工程

### 3.1 提示词设计原则

1. **明确的角色定位**
   - 定义AI为专业设计专家
   - 赋予明确的任务职责

2. **清晰的约束条件**
   - 内容不变原则
   - 输出格式要求
   - 设计规范限制

3. **结构化输入**
   - 使用JSON格式传递数据
   - 清晰的层次结构
   - 必要的上下文信息

4. **示例驱动**
   - 提供输出格式示例
   - 展示期望的结果结构

### 3.2 提示词优化技巧

1. **温度参数**
   ```python
   temperature = 0.7  # 平衡创造性和稳定性
   ```
   - 0.5-0.7：适合设计类任务
   - 0.8-1.0：更有创意但不稳定
   - 0.0-0.4：过于保守

2. **Token限制**
   ```python
   max_tokens = 2000  # 足够生成完整响应
   ```

3. **输入压缩**
   - 只传递必要字段
   - 移除冗余信息
   - 使用简洁的表达

---

## 4. 最佳实践和注意事项

### 4.1 前端最佳实践

1. **用户体验**
   ```typescript
   // ✅ 好的做法
   - 显示Loading状态
   - 提供取消操作
   - 显示优化进度
   - 支持撤销操作
   - 提供预览对比

   // ❌ 避免的做法
   - 无Loading反馈
   - 阻塞用户操作
   - 不支持撤销
   - 直接覆盖原数据
   ```

2. **错误处理**
   ```typescript
   // ✅ 完善的错误处理
   try {
     const result = await optimizeLayout();
     handleSuccess(result);
   } catch (error) {
     if (error instanceof NetworkError) {
       showNetworkError();
     } else if (error instanceof TimeoutError) {
       showTimeoutError();
     } else {
       showGenericError(error);
     }
   }

   // ❌ 简单的错误处理
   try {
     await optimizeLayout();
   } catch (error) {
     console.error(error); // 用户看不到
   }
   ```

3. **性能优化**
   ```typescript
   // ✅ 数据精简
   const simplified = elements.map(el => ({
     id: el.id,
     type: el.type,
     // 只包含必要字段
     ...getEssentialFields(el)
   }));

   // ❌ 传输完整数据
   const fullData = elements; // 包含大量冗余信息
   ```

### 4.2 后端最佳实践

1. **缓存策略**
   ```python
   # ✅ 智能缓存
   - 基于内容哈希的缓存键
   - 合理的过期时间
   - 缓存失效策略

   # ❌ 简单缓存
   - 基于时间戳的缓存键（每次都不同）
   - 永久缓存（占用内存）
   - 无失效机制
   ```

2. **错误恢复**
   ```python
   # ✅ 渐进式降级
   try:
       result = await optimize_with_llm()
   except LLMError:
       # 降级到规则引擎
       result = optimize_with_rules()
   except Exception:
       # 返回原始数据
       result = original_elements

   # ❌ 直接失败
   result = await optimize_with_llm()  # 失败就完全失败
   ```

3. **资源管理**
   ```python
   # ✅ 并发控制
   semaphore = asyncio.Semaphore(5)
   async with semaphore:
       await call_llm()

   # ❌ 无限并发
   await call_llm()  # 可能导致资源耗尽
   ```

### 4.3 LLM调用最佳实践

1. **超时控制**
   ```python
   # ✅ 设置超时
   try:
       async with timeout(30):
           response = await ai_client.ai_call(prompt)
   except asyncio.TimeoutError:
       raise OptimizationTimeout()

   # ❌ 无超时
   response = await ai_client.ai_call(prompt)  # 可能永久等待
   ```

2. **重试机制**
   ```python
   # ✅ 指数退避重试
   @retry(
       stop=stop_after_attempt(3),
       wait=wait_exponential(min=1, max=10)
   )
   async def call_llm_with_retry():
       return await ai_client.ai_call(prompt)

   # ❌ 无重试
   return await ai_client.ai_call(prompt)  # 一次失败就失败
   ```

3. **结果验证**
   ```python
   # ✅ 完整验证
   def validate_llm_response(response, original):
       # 验证格式
       assert isinstance(response, dict)
       # 验证字段
       assert "optimized_elements" in response
       # 验证内容
       assert len(response["optimized_elements"]) == len(original)
       # 验证内容不变
       for orig, opt in zip(original, response["optimized_elements"]):
           if orig.type == "text":
               assert orig.content == opt.content

   # ❌ 无验证
   return response  # 直接使用LLM输出
   ```

### 4.4 安全性考虑

1. **输入验证**
   ```python
   # ✅ 严格验证
   - 元素数量限制
   - 字段类型检查
   - 数值范围验证
   - 内容长度限制

   # ❌ 无验证
   - 接受任意输入
   - 不检查边界条件
   ```

2. **输出过滤**
   ```python
   # ✅ 输出过滤
   - 移除敏感信息
   - 验证数据完整性
   - 确保格式正确

   # ❌ 直接返回
   - 可能包含调试信息
   - 可能包含错误数据
   ```

3. **访问控制**
   ```python
   # ✅ 权限检查
   - 验证用户身份
   - 检查操作权限
   - 限制请求频率

   # ❌ 无控制
   - 任何人都可以调用
   - 无频率限制
   ```

---

**文档维护者**: AI开发团队  
**最后更新**: 2025-10-28  
**版本**: v1.0

