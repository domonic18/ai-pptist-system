# 多模态自动标注系统架构设计 v2.0 - 第二部分

## 3.2.5 多模态分析服务

**analysis_service.py** - 多模态LLM分析

```python
"""
多模态分析服务

职责:
- 调用多模态LLM进行幻灯片分析
- 管理提示词和参数
- 处理LLM响应
- 错误重试机制
"""

from typing import Dict, Any, List, Optional
import json
import base64

from app.core.llm.multimodal_client import MultimodalLLMClient
from app.repositories.ai_model import AIModelRepository
from app.core.log_utils import get_logger
from app.prompts.annotation import ANNOTATION_PROMPTS

logger = get_logger(__name__)


class AnalysisService:
    """多模态分析服务"""

    def __init__(self):
        self.llm_client = MultimodalLLMClient()

    async def analyze_slide(
        self,
        screenshot: str,
        elements: List[Dict[str, Any]],
        model_config: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        分析幻灯片

        Args:
            screenshot: 幻灯片截图（Base64编码）
            elements: 元素数据列表
            model_config: 模型配置

        Returns:
            Dict[str, Any]: 分析结果
        """
        try:
            logger.info("开始分析幻灯片")

            # 1. 构建提示词
            prompt = self._build_analysis_prompt(elements)

            # 2. 调用多模态LLM
            llm_response = await self._call_llm_with_retry(
                screenshot=screenshot,
                prompt=prompt,
                model_config=model_config
            )

            # 3. 解析响应
            result = self._parse_llm_response(llm_response)

            # 4. 验证结果
            self._validate_analysis_result(result, elements)

            logger.info(
                "幻灯片分析完成",
                extra={
                    "page_type": result.get("page_type", {}).get("type"),
                    "layout_type": result.get("layout_type", {}).get("type"),
                    "element_count": len(result.get("element_annotations", []))
                }
            )

            return result

        except Exception as e:
            logger.error("幻灯片分析失败", exception=e)
            raise

    def _build_analysis_prompt(
        self,
        elements: List[Dict[str, Any]]
    ) -> str:
        """
        构建分析提示词

        Args:
            elements: 元素数据列表

        Returns:
            str: 提示词
        """
        # 构建元素信息描述
        elements_desc = []
        for i, elem in enumerate(elements):
            elem_desc = f"""
元素 {i+1}:
- ID: {elem.get('id')}
- 类型: {elem.get('type')}
- 位置: left={elem.get('left')}, top={elem.get('top')}
- 尺寸: width={elem.get('width')}, height={elem.get('height')}
- 内容: {elem.get('content', 'N/A')[:100]}
"""
            elements_desc.append(elem_desc.strip())

        elements_info = "\n\n".join(elements_desc)

        # 使用预定义的提示词模板
        prompt = ANNOTATION_PROMPTS["slide_analysis"].format(
            elements_count=len(elements),
            elements_info=elements_info
        )

        return prompt

    async def _call_llm_with_retry(
        self,
        screenshot: str,
        prompt: str,
        model_config: Optional[Dict[str, Any]] = None,
        max_retries: int = 3
    ) -> Dict[str, Any]:
        """
        调用LLM并支持重试

        Args:
            screenshot: 截图
            prompt: 提示词
            model_config: 模型配置
            max_retries: 最大重试次数

        Returns:
            Dict[str, Any]: LLM响应
        """
        last_error = None

        for attempt in range(max_retries):
            try:
                logger.info(
                    f"调用多模态LLM (尝试 {attempt + 1}/{max_retries})",
                    extra={
                        "model": model_config.get("model_id") if model_config else "default"
                    }
                )

                response = await self.llm_client.analyze_with_vision(
                    image_base64=screenshot,
                    prompt=prompt,
                    model=model_config.get("model_id") if model_config else None,
                    temperature=0.2,  # 降低随机性，提高一致性
                    max_tokens=2000
                )

                return response

            except Exception as e:
                last_error = e
                logger.warning(
                    f"LLM调用失败 (尝试 {attempt + 1}/{max_retries})",
                    extra={"error": str(e)}
                )

                if attempt < max_retries - 1:
                    # 等待后重试
                    await asyncio.sleep(2 ** attempt)  # 指数退避
                else:
                    raise last_error

    def _parse_llm_response(
        self,
        llm_response: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        解析LLM响应

        Args:
            llm_response: LLM响应

        Returns:
            Dict[str, Any]: 解析后的结果
        """
        try:
            # 提取内容
            content = llm_response.get("content", "")

            # 解析JSON
            # 假设LLM返回的是JSON格式
            if "```json" in content:
                # 提取JSON代码块
                json_start = content.find("```json") + 7
                json_end = content.find("```", json_start)
                content = content[json_start:json_end].strip()

            result = json.loads(content)

            return result

        except json.JSONDecodeError as e:
            logger.error(
                "LLM响应JSON解析失败",
                extra={"content": content[:500]}
            )
            # 尝试修复JSON
            return self._try_fix_json(content)
        except Exception as e:
            logger.error("LLM响应解析失败", exception=e)
            raise

    def _try_fix_json(self, content: str) -> Dict[str, Any]:
        """
        尝试修复损坏的JSON

        Args:
            content: JSON字符串

        Returns:
            Dict[str, Any]: 修复后的结果
        """
        # 简单的JSON修复逻辑
        # 1. 移除多余的逗号
        content = content.replace(",]", "]").replace(",}", "}")

        # 2. 补全缺失的引号
        # 这里可以添加更复杂的修复逻辑

        try:
            return json.loads(content)
        except json.JSONDecodeError:
            raise ValueError("无法修复JSON格式")

    def _validate_analysis_result(
        self,
        result: Dict[str, Any],
        elements: List[Dict[str, Any]]
    ):
        """
        验证分析结果

        Args:
            result: 分析结果
            elements: 原始元素列表

        Raises:
            ValueError: 如果结果无效
        """
        # 检查必需字段
        required_fields = ["page_type", "layout_type", "element_annotations"]
        for field in required_fields:
            if field not in result:
                raise ValueError(f"缺少必需字段: {field}")

        # 检查页面类型
        if "type" not in result["page_type"]:
            raise ValueError("页面类型缺少type字段")

        # 检查布局类型
        if "type" not in result["layout_type"]:
            raise ValueError("布局类型缺少type字段")

        # 检查元素标注
        annotated_element_ids = {
            ann.get("element_id")
            for ann in result["element_annotations"]
        }
        original_element_ids = {elem.get("id") for elem in elements}

        # 警告：未标注的元素
        missing_annotations = original_element_ids - annotated_element_ids
        if missing_annotations:
            logger.warning(
                f"有 {len(missing_annotations)} 个元素未被标注",
                extra={"missing_ids": list(missing_annotations)}
            )

        # 警告：标注了不存在的元素
        extra_annotations = annotated_element_ids - original_element_ids
        if extra_annotations:
            logger.warning(
                f"标注了 {len(extra_annotations)} 个不存在的元素",
                extra={"extra_ids": list(extra_annotations)}
            )


class MultimodalLLMClient:
    """多模态LLM客户端"""

    def __init__(self):
        self.model_repo = AIModelRepository()

    async def analyze_with_vision(
        self,
        image_base64: str,
        prompt: str,
        model: Optional[str] = None,
        temperature: float = 0.2,
        max_tokens: int = 2000
    ) -> Dict[str, Any]:
        """
        使用视觉模型进行分析

        Args:
            image_base64: Base64编码的图片
            prompt: 提示词
            model: 模型ID
            temperature: 温度参数
            max_tokens: 最大token数

        Returns:
            Dict[str, Any]: 模型响应
        """
        # 获取模型配置
        if model:
            model_config = await self.model_repo.get_model_by_id(model)
        else:
            # 获取默认的多模态模型
            model_config = await self.model_repo.get_default_multimodal_model()

        if not model_config:
            raise ValueError("未找到可用的多模态模型")

        # 根据模型类型调用对应的客户端
        if model_config.provider == "openai":
            return await self._call_openai_vision(
                image_base64,
                prompt,
                model_config,
                temperature,
                max_tokens
            )
        elif model_config.provider == "google":
            return await self._call_gemini_vision(
                image_base64,
                prompt,
                model_config,
                temperature,
                max_tokens
            )
        elif model_config.provider == "anthropic":
            return await self._call_claude_vision(
                image_base64,
                prompt,
                model_config,
                temperature,
                max_tokens
            )
        else:
            raise ValueError(f"不支持的模型提供商: {model_config.provider}")

    async def _call_openai_vision(
        self,
        image_base64: str,
        prompt: str,
        model_config: Any,
        temperature: float,
        max_tokens: int
    ) -> Dict[str, Any]:
        """调用OpenAI Vision API"""
        import openai

        client = openai.AsyncOpenAI(api_key=model_config.api_key)

        response = await client.chat.completions.create(
            model=model_config.model_name,  # 例如 "gpt-4-vision-preview"
            messages=[
                {
                    "role": "user",
                    "content": [
                        {
                            "type": "text",
                            "text": prompt
                        },
                        {
                            "type": "image_url",
                            "image_url": {
                                "url": f"data:image/png;base64,{image_base64}"
                            }
                        }
                    ]
                }
            ],
            temperature=temperature,
            max_tokens=max_tokens
        )

        return {
            "content": response.choices[0].message.content,
            "model": model_config.model_name,
            "usage": {
                "prompt_tokens": response.usage.prompt_tokens,
                "completion_tokens": response.usage.completion_tokens,
                "total_tokens": response.usage.total_tokens
            }
        }

    async def _call_gemini_vision(
        self,
        image_base64: str,
        prompt: str,
        model_config: Any,
        temperature: float,
        max_tokens: int
    ) -> Dict[str, Any]:
        """调用Google Gemini Vision API"""
        import google.generativeai as genai

        genai.configure(api_key=model_config.api_key)
        model = genai.GenerativeModel(model_config.model_name)

        # 解码Base64图片
        image_data = base64.b64decode(image_base64)

        response = await model.generate_content_async(
            [prompt, {"mime_type": "image/png", "data": image_data}],
            generation_config={
                "temperature": temperature,
                "max_output_tokens": max_tokens
            }
        )

        return {
            "content": response.text,
            "model": model_config.model_name,
            "usage": {
                "prompt_tokens": response.usage_metadata.prompt_token_count,
                "completion_tokens": response.usage_metadata.candidates_token_count,
                "total_tokens": response.usage_metadata.total_token_count
            }
        }

    async def _call_claude_vision(
        self,
        image_base64: str,
        prompt: str,
        model_config: Any,
        temperature: float,
        max_tokens: int
    ) -> Dict[str, Any]:
        """调用Anthropic Claude Vision API"""
        import anthropic

        client = anthropic.AsyncAnthropic(api_key=model_config.api_key)

        response = await client.messages.create(
            model=model_config.model_name,  # 例如 "claude-3-opus-20240229"
            max_tokens=max_tokens,
            temperature=temperature,
            messages=[
                {
                    "role": "user",
                    "content": [
                        {
                            "type": "image",
                            "source": {
                                "type": "base64",
                                "media_type": "image/png",
                                "data": image_base64
                            }
                        },
                        {
                            "type": "text",
                            "text": prompt
                        }
                    ]
                }
            ]
        )

        return {
            "content": response.content[0].text,
            "model": model_config.model_name,
            "usage": {
                "prompt_tokens": response.usage.input_tokens,
                "completion_tokens": response.usage.output_tokens,
                "total_tokens": response.usage.input_tokens + response.usage.output_tokens
            }
        }
```

## 3.3 数据模型设计

### 3.3.1 数据库模型

**annotation.py** - 标注任务模型

```python
"""
标注数据模型
"""

from sqlalchemy import Column, String, Integer, Float, JSON, DateTime, Enum
from sqlalchemy.sql import func
import enum

from app.db.database import Base


class AnnotationTaskStatus(str, enum.Enum):
    """标注任务状态"""
    PENDING = "pending"
    PROCESSING = "processing"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"


class AnnotationTask(Base):
    """标注任务表"""
    __tablename__ = "annotation_tasks"

    id = Column(String(50), primary_key=True)
    user_id = Column(String(50), nullable=False, index=True)
    presentation_id = Column(String(50), nullable=False, index=True)
    status = Column(Enum(AnnotationTaskStatus), default=AnnotationTaskStatus.PENDING, index=True)

    # 任务配置
    model_id = Column(String(50), nullable=True)
    model_config = Column(JSON, nullable=True)
    extraction_config = Column(JSON, nullable=True)

    # 进度信息
    total_pages = Column(Integer, default=0)
    completed_pages = Column(Integer, default=0)
    failed_pages = Column(Integer, default=0)

    # 统计信息
    average_confidence = Column(Float, default=0.0)
    total_corrections = Column(Integer, default=0)

    # 时间信息
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    started_at = Column(DateTime(timezone=True), nullable=True)
    completed_at = Column(DateTime(timezone=True), nullable=True)

    def to_dict(self):
        return {
            "id": self.id,
            "user_id": self.user_id,
            "presentation_id": self.presentation_id,
            "status": self.status.value,
            "model_id": self.model_id,
            "total_pages": self.total_pages,
            "completed_pages": self.completed_pages,
            "failed_pages": self.failed_pages,
            "average_confidence": self.average_confidence,
            "total_corrections": self.total_corrections,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None
        }


class SlideAnnotation(Base):
    """幻灯片标注结果表"""
    __tablename__ = "slide_annotations"

    id = Column(String(50), primary_key=True)
    task_id = Column(String(50), nullable=False, index=True)
    slide_id = Column(String(50), nullable=False, index=True)
    slide_index = Column(Integer, nullable=False)

    # 页面类型
    page_type = Column(String(50), nullable=True)
    page_type_confidence = Column(Float, nullable=True)
    page_type_reason = Column(String(500), nullable=True)

    # 布局类型
    layout_type = Column(String(50), nullable=True)
    layout_type_confidence = Column(Float, nullable=True)
    layout_type_reason = Column(String(500), nullable=True)

    # 元素标注（JSON格式）
    element_annotations = Column(JSON, nullable=True)

    # 整体置信度
    overall_confidence = Column(Float, nullable=True)

    # 用户修正
    user_corrections = Column(JSON, nullable=True)
    has_corrections = Column(Integer, default=0)

    # 时间信息
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    def to_dict(self):
        return {
            "id": self.id,
            "task_id": self.task_id,
            "slide_id": self.slide_id,
            "slide_index": self.slide_index,
            "page_type": {
                "type": self.page_type,
                "confidence": self.page_type_confidence,
                "reason": self.page_type_reason
            },
            "layout_type": {
                "type": self.layout_type,
                "confidence": self.layout_type_confidence,
                "reason": self.layout_type_reason
            },
            "element_annotations": self.element_annotations,
            "overall_confidence": self.overall_confidence,
            "user_corrections": self.user_corrections,
            "has_corrections": self.has_corrections == 1,
            "created_at": self.created_at.isoformat() if self.created_at else None
        }
```

### 3.3.2 Pydantic Schema

**annotation.py** - 请求/响应模型

```python
"""
标注Schema定义
"""

from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any
from datetime import datetime


class SlideDataSchema(BaseModel):
    """幻灯片数据Schema"""
    slide_id: str = Field(..., description="幻灯片ID")
    screenshot: str = Field(..., description="截图Base64编码")
    elements: List[Dict[str, Any]] = Field(..., description="元素数据列表")


class ModelConfigSchema(BaseModel):
    """模型配置Schema"""
    model_id: str = Field(..., description="模型ID")
    multimodal_enabled: bool = Field(True, description="是否启用多模态")


class ExtractionConfigSchema(BaseModel):
    """提取配置Schema"""
    screenshot_quality: str = Field("high", description="截图质量")
    include_element_data: bool = Field(True, description="是否包含元素数据")


class AnnotationStartRequest(BaseModel):
    """启动标注请求"""
    slides: List[Dict[str, Any]] = Field(..., description="幻灯片数据")
    model_config: Optional[ModelConfigSchema] = Field(None, description="模型配置")
    extraction_config: Optional[ExtractionConfigSchema] = Field(None, description="提取配置")


class PageTypeResult(BaseModel):
    """页面类型结果"""
    type: str = Field(..., description="页面类型")
    confidence: float = Field(..., ge=0.0, le=1.0, description="置信度")
    reason: str = Field(..., description="识别依据")


class LayoutTypeResult(BaseModel):
    """布局类型结果"""
    type: str = Field(..., description="布局类型")
    confidence: float = Field(..., ge=0.0, le=1.0, description="置信度")
    reason: str = Field(..., description="识别依据")


class ElementAnnotationResult(BaseModel):
    """元素标注结果"""
    element_id: str = Field(..., description="元素ID")
    type: str = Field(..., description="元素类型")
    confidence: float = Field(..., ge=0.0, le=1.0, description="置信度")
    reason: str = Field(..., description="识别依据")


class SlideAnnotationResult(BaseModel):
    """幻灯片标注结果"""
    slide_id: str = Field(..., description="幻灯片ID")
    page_type: PageTypeResult = Field(..., description="页面类型")
    layout_type: LayoutTypeResult = Field(..., description="布局类型")
    element_annotations: List[ElementAnnotationResult] = Field(..., description="元素标注列表")
    overall_confidence: float = Field(..., ge=0.0, le=1.0, description="整体置信度")


class AnnotationProgressResponse(BaseModel):
    """标注进度响应"""
    task_id: str = Field(..., description="任务ID")
    status: str = Field(..., description="任务状态")
    progress: Dict[str, Any] = Field(..., description="进度信息")
    current_page: int = Field(..., description="当前页")
    estimated_remaining_time: int = Field(..., description="预计剩余时间(秒)")


class AnnotationResultResponse(BaseModel):
    """标注结果响应"""
    task_id: str = Field(..., description="任务ID")
    status: str = Field(..., description="任务状态")
    results: List[SlideAnnotationResult] = Field(..., description="标注结果列表")
    statistics: Dict[str, Any] = Field(..., description="统计信息")
```

### 3.3.3 AI模型扩展

**扩展AIModel表以支持多模态**

```sql
-- 添加多模态相关字段
ALTER TABLE ai_models ADD COLUMN supports_multimodal BOOLEAN DEFAULT FALSE;
ALTER TABLE ai_models ADD COLUMN max_image_size VARCHAR(50);
ALTER TABLE ai_models ADD COLUMN supported_image_formats JSON;
ALTER TABLE ai_models ADD COLUMN vision_capabilities JSON;

-- 创建索引
CREATE INDEX idx_ai_models_multimodal ON ai_models(supports_multimodal, is_active);

-- 示例数据
INSERT INTO ai_models (
    id, name, provider, model_name, 
    supports_multimodal, max_image_size, supported_image_formats,
    vision_capabilities, is_active
) VALUES (
    'model_gpt4v',
    'GPT-4 Vision',
    'openai',
    'gpt-4-vision-preview',
    TRUE,
    '2048x2048',
    '["png", "jpeg", "gif", "webp"]',
    '["image_analysis", "text_recognition", "layout_detection", "object_detection"]',
    TRUE
);
```

## 3.4 Prompt设计

### 3.4.1 主提示词模板

```python
# backend/app/prompts/annotation/__init__.py

ANNOTATION_PROMPTS = {
    "slide_analysis": """你是一个专业的PPT设计分析专家。请分析这张幻灯片的截图和元素信息，完成以下任务：

## 任务

1. **页面类型识别**：识别这页幻灯片的内容类型
2. **布局类型识别**：识别这页幻灯片使用的SmartArt布局类型
3. **元素类型标注**：为每个元素标注正确的类型

## 幻灯片信息

- 总元素数: {elements_count}
- 元素详情:
{elements_info}

## 页面类型定义

1. **cover** - 封面页
   - 特征：包含主标题、副标题，通常元素较少，布局居中
   - 示例：演示文稿的第一页，公司Logo + 标题 + 作者

2. **catalog** - 目录页
   - 特征：包含章节列表、编号，结构化展示
   - 示例：第一章、第二章、第三章的列表

3. **transition** - 过渡页/章节页
   - 特征：简洁的标题页，用于分隔章节
   - 示例：只有大标题"第二章 市场分析"

4. **concept_explanation** - 概念说明页
   - 特征：解释某个概念、定义、理论
   - 示例：什么是SWOT分析？包含定义和说明

5. **data_analysis** - 数据分析页
   - 特征：包含图表、数据表格、统计信息
   - 示例：销售额趋势图、数据对比表

6. **case_study** - 案例展示页
   - 特征：展示具体案例、实例、场景
   - 示例：成功案例介绍、客户案例

7. **conclusion** - 总结页
   - 特征：总结要点、结论、关键信息
   - 示例：核心要点总结、结论与展望

8. **thank_you** - 致谢页
   - 特征：演示文稿结尾，感谢听众
   - 示例：谢谢观看、联系方式

## 布局类型定义

1. **vertical_list** - 垂直列表
   - 特征：元素垂直排列，从上到下
   - 适用：要点列举、步骤说明

2. **horizontal_list** - 水平列表
   - 特征：元素水平排列，从左到右
   - 适用：流程展示、时间线

3. **grid** - 网格布局
   - 特征：元素按网格排列（如2x2, 3x3）
   - 适用：多个平等要点、对比展示

4. **hierarchy** - 层级结构
   - 特征：有明显的层级关系
   - 适用：组织架构、分类说明

5. **cycle** - 循环结构
   - 特征：元素呈循环关系
   - 适用：循环流程、持续改进

6. **relationship** - 关系结构
   - 特征：展示元素间的关系
   - 适用：因果关系、相互影响

7. **matrix** - 矩阵布局
   - 特征：二维矩阵结构
   - 适用：多维度分析、象限图

8. **funnel** - 漏斗结构
   - 特征：从大到小的漏斗形状
   - 适用：销售漏斗、筛选流程

9. **pyramid** - 金字塔结构
   - 特征：金字塔形状，底部宽顶部窄
   - 适用：层次结构、优先级展示

10. **free_form** - 自由布局
    - 特征：无明显规律的自由排列
    - 适用：创意展示、个性化设计

## 元素类型定义

### 文本元素
- **slide_title**: 幻灯片主标题
- **subtitle**: 副标题
- **item_title**: 列表项标题
- **item**: 列表项内容
- **content**: 普通文本内容
- **number**: 数字、序号
- **decoration**: 装饰性文本

### 形状元素
- **title_bg**: 标题背景形状
- **item_bg**: 列表项背景形状
- **section_bg**: 区域背景形状
- **decoration**: 装饰形状
- **icon**: 图标形状

### 图片元素
- **main_image**: 主要图片
- **background_image**: 背景图片
- **icon_image**: 图标图片
- **decoration_image**: 装饰图片

### SVG元素
- **chart**: 图表
- **arrow**: 箭头
- **bullet**: 项目符号
- **decoration**: 装饰SVG

## 输出格式

请以JSON格式输出分析结果（不要包含任何其他文字说明）：

```json
{
  "page_type": {
    "type": "页面类型",
    "confidence": 0.95,
    "reason": "识别依据说明"
  },
  "layout_type": {
    "type": "布局类型",
    "confidence": 0.90,
    "reason": "识别依据说明"
  },
  "element_annotations": [
    {
      "element_id": "元素ID",
      "type": "元素类型",
      "confidence": 0.92,
      "reason": "识别依据说明"
    }
  ]
}
```

## 注意事项

1. 置信度（confidence）取值范围：0.0-1.0
2. 必须为每个元素提供标注
3. reason字段应简明扼要地说明判断依据
4. 如果不确定，可以给较低的置信度
5. 优先考虑元素的位置、大小、内容来判断类型

请开始分析：
""",

    "page_type_only": """请识别这张幻灯片的页面类型。

## 可选类型
- cover: 封面页
- catalog: 目录页
- transition: 过渡页
- concept_explanation: 概念说明
- data_analysis: 数据分析
- case_study: 案例展示
- conclusion: 总结页
- thank_you: 致谢页

## 输出格式
```json
{
  "type": "页面类型",
  "confidence": 0.95,
  "reason": "简要说明"
}
```
""",

    "layout_type_only": """请识别这张幻灯片的布局类型。

## 可选类型
- vertical_list: 垂直列表
- horizontal_list: 水平列表
- grid: 网格布局
- hierarchy: 层级结构
- cycle: 循环结构
- relationship: 关系结构
- matrix: 矩阵布局
- funnel: 漏斗结构
- pyramid: 金字塔结构
- free_form: 自由布局

## 输出格式
```json
{
  "type": "布局类型",
  "confidence": 0.90,
  "reason": "简要说明"
}
```
"""
}
```

## 4. 部署与运维

### 4.1 环境配置

```bash
# .env文件配置

# 标注服务配置
ANNOTATION_ENABLED=true
ANNOTATION_DEFAULT_MODEL=model_gpt4v
ANNOTATION_MAX_CONCURRENT_TASKS=5
ANNOTATION_TASK_TIMEOUT=600  # 10分钟

# LLM配置
OPENAI_API_KEY=your_openai_api_key
GOOGLE_API_KEY=your_google_api_key
ANTHROPIC_API_KEY=your_anthropic_api_key

# 缓存配置
ANNOTATION_CACHE_ENABLED=true
ANNOTATION_CACHE_TTL=86400  # 24小时

# 重试配置
ANNOTATION_MAX_RETRIES=3
ANNOTATION_RETRY_DELAY=2  # 秒

# 性能配置
ANNOTATION_BATCH_SIZE=5
ANNOTATION_PARALLEL_WORKERS=3
```

### 4.2 Docker配置

```dockerfile
# backend/Dockerfile

FROM python:3.11-slim

WORKDIR /app

# 安装依赖
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 复制代码
COPY . .

# 环境变量
ENV PYTHONUNBUFFERED=1
ENV ANNOTATION_WORKERS=4

# 启动命令
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000", "--workers", "4"]
```

```yaml
# docker-compose.yml 扩展

services:
  backend:
    environment:
      - ANNOTATION_ENABLED=true
      - ANNOTATION_DEFAULT_MODEL=model_gpt4v
      - REDIS_URL=redis://redis:6379/0

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    command: redis-server --appendonly yes

volumes:
  redis_data:
```

### 4.3 监控指标

```python
# backend/app/core/metrics.py

from prometheus_client import Counter, Histogram, Gauge

# 标注任务指标
annotation_tasks_total = Counter(
    'annotation_tasks_total',
    'Total number of annotation tasks',
    ['status']
)

annotation_duration_seconds = Histogram(
    'annotation_duration_seconds',
    'Duration of annotation tasks',
    buckets=[10, 30, 60, 120, 300, 600]
)

annotation_confidence_score = Gauge(
    'annotation_confidence_score',
    'Average confidence score of annotations'
)

annotation_llm_calls_total = Counter(
    'annotation_llm_calls_total',
    'Total number of LLM API calls',
    ['model', 'status']
)

annotation_cache_hits_total = Counter(
    'annotation_cache_hits_total',
    'Total number of cache hits',
    ['hit_or_miss']
)
```

## 5. 测试策略

### 5.1 单元测试

```python
# backend/tests/unit/services/test_annotation_service.py

import pytest
from unittest.mock import Mock, patch, AsyncMock

from app.services.annotation.annotation_service import AnnotationService


class TestAnnotationService:
    """标注服务单元测试"""

    @pytest.fixture
    def service(self, db_session):
        """创建服务实例"""
        return AnnotationService(db_session)

    @pytest.mark.asyncio
    async def test_start_annotation_success(self, service):
        """测试启动标注成功"""
        slides = [
            {
                "slide_id": "slide_1",
                "screenshot": "base64_image_data",
                "elements": []
            }
        ]

        result = await service.start_annotation(
            slides=slides,
            model_config={"model_id": "test_model"}
        )

        assert "task_id" in result
        assert result["total_pages"] == 1

    @pytest.mark.asyncio
    async def test_analyze_slide_with_cache(self, service):
        """测试使用缓存分析幻灯片"""
        slide = {
            "slide_id": "slide_1",
            "screenshot": "base64_image_data",
            "elements": []
        }

        # Mock缓存
        with patch.object(service, '_get_cached_result') as mock_cache:
            mock_cache.return_value = {"page_type": {"type": "cover"}}

            result = await service._analyze_slide(slide, None)

            assert result["page_type"]["type"] == "cover"
            mock_cache.assert_called_once()
```

### 5.2 集成测试

```python
# backend/tests/integration/test_annotation_api.py

import pytest
from httpx import AsyncClient

from app.main import app


class TestAnnotationAPI:
    """标注API集成测试"""

    @pytest.mark.asyncio
    async def test_annotation_flow(self):
        """测试完整的标注流程"""
        async with AsyncClient(app=app, base_url="http://test") as client:
            # 1. 启动标注
            response = await client.post(
                "/api/v1/annotation/start",
                json={
                    "slides": [
                        {
                            "slide_id": "slide_1",
                            "screenshot": "test_base64_data",
                            "elements": []
                        }
                    ],
                    "model_config": {
                        "model_id": "test_model",
                        "multimodal_enabled": True
                    }
                }
            )

            assert response.status_code == 200
            data = response.json()
            assert data["status"] == "success"
            task_id = data["data"]["task_id"]

            # 2. 查询进度
            response = await client.get(
                f"/api/v1/annotation/progress/{task_id}"
            )

            assert response.status_code == 200

            # 3. 获取结果
            # (等待任务完成...)
            response = await client.get(
                f"/api/v1/annotation/results/{task_id}"
            )

            assert response.status_code == 200
            data = response.json()
            assert len(data["data"]["results"]) > 0
```

## 6. 实施计划

### 6.1 开发阶段划分

**Phase 1: 基础架构（2周）**
- [ ] 数据库表设计和创建
- [ ] API端点框架搭建
- [ ] 前端基础组件开发
- [ ] 多模态LLM客户端封装

**Phase 2: 核心功能（3周）**
- [ ] 幻灯片数据提取服务
- [ ] 多模态分析服务
- [ ] 标注结果处理服务
- [ ] 缓存和队列机制

**Phase 3: 用户界面（2周）**
- [ ] 标注触发和进度展示
- [ ] 可视化标注渲染
- [ ] 确认和编辑界面
- [ ] 批量操作功能

**Phase 4: 测试优化（2周）**
- [ ] 单元测试和集成测试
- [ ] 性能测试和优化
- [ ] Prompt调优
- [ ] Bug修复

**Phase 5: 上线部署（1周）**
- [ ] 生产环境配置
- [ ] 监控告警配置
- [ ] 用户文档编写
- [ ] 灰度发布

### 6.2 里程碑

| 里程碑 | 时间 | 交付物 |
|--------|------|--------|
| M1: 架构设计完成 | Week 1 | 架构设计文档、技术选型 |
| M2: 后端API可用 | Week 3 | 完整的API端点、单元测试 |
| M3: 前端界面完成 | Week 5 | 可交互的前端界面 |
| M4: 集成测试通过 | Week 7 | 端到端功能验证 |
| M5: Beta版本发布 | Week 9 | 内部测试版本 |
| M6: 正式版上线 | Week 10 | 生产环境部署 |

## 7. 风险与应对

### 7.1 技术风险

| 风险 | 概率 | 影响 | 应对措施 |
|------|------|------|----------|
| LLM API不稳定 | 中 | 高 | 重试机制、降级方案、多模型支持 |
| 标注准确率不足 | 中 | 中 | Prompt优化、人工审核、持续训练 |
| 性能瓶颈 | 低 | 中 | 缓存策略、异步处理、批量优化 |
| 成本过高 | 中 | 中 | 缓存复用、模型选择、用量控制 |

### 7.2 业务风险

| 风险 | 概率 | 影响 | 应对措施 |
|------|------|------|----------|
| 用户接受度低 | 低 | 高 | 灰度发布、用户培训、功能迭代 |
| 标注结果争议 | 中 | 中 | 提供修正机制、置信度展示 |

## 8. 总结

本架构设计基于AI PPTist项目的现有技术栈和规范体系，实现了完整的多模态自动标注功能。核心特点包括：

1. **遵循项目规范**：严格遵循API设计规范、响应格式规范、日志记录规范
2. **分层架构清晰**：端点层、处理器层、服务层、仓库层职责明确
3. **多模态AI集成**：支持OpenAI、Google、Anthropic等多种多模态模型
4. **高性能设计**：缓存机制、异步处理、批量优化
5. **完整的用户体验**：可视化标注、进度展示、确认编辑
6. **可运维可监控**：完整的日志、指标、告警体系

该设计能够满足需求文档中的所有功能要求，并为未来的功能扩展预留了空间。

